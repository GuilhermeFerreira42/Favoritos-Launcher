<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gerenciador de Favoritos</title>
    
    <style>
        /* --- Reset Básico e Estilos Globais --- */
        :root {
            --background-start: #1e3a8a; /* Azul escuro */ 
            --background-end: #0c1a4d; /* Azul mais escuro */ 
            --group-background: rgba(17, 24, 39, 0.7); /* Fundo do grupo semi-transparente */ 
            --text-color: #f1f5f9; /* Branco acinzentado */ 
            --border-color: rgba(255, 255, 255, 0.1);
            --hover-shadow: 0 0 15px rgba(59, 130, 246, 0.5); /* Sombra azul no hover */ 
        }

        /* Garante que a base da página ocupe toda a tela */
        html, body {
            height: 100%;
            overflow: hidden; /* Previne barras de rolagem duplas e indesejadas no corpo da página */
        }

        * {
            margin: 0;
            padding: 0; 
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
            color: var(--text-color); 
            background-color: var(--background-end); 
            background-image: linear-gradient(145deg, var(--background-start), var(--background-end)); 
            background-size: cover; 
            background-position: center; 
            background-attachment: fixed; 
            min-height: 100vh;
            display: flex; /* Transforma o body em um contêiner flex */
        }

        /* --- Estrutura Principal --- */
        .container {
            display: flex;          /* Também se torna um contêiner flex */
            flex-direction: column; /* Organiza o header e a área de grupos verticalmente */
            flex-grow: 1;           /* FAZ O CONTAINER CRESCER PARA OCUPAR TODO O ESPAÇO DO BODY */
            padding: 2rem;
            width: 100%;
            overflow: hidden;       /* Garante que o padding não cause problemas de layout */
        }

        /* --- Barra Superior --- */
        .top-bar {
            display: flex;
            justify-content: center; 
            align-items: center; 
            margin-bottom: 2rem;
            position: relative; 
        }

        .search-bar {
            width: 100%;
            max-width: 500px; 
            padding: 0.75rem 1.5rem; 
            border-radius: 50px; 
            border: 1px solid var(--border-color); 
            background-color: var(--group-background); 
            color: var(--text-color); 
            font-size: 1rem; 
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px); 
        }

        .search-bar::placeholder {
            color: rgba(255, 255, 255, 0.5);
        }

        .context-menu-btn {
            position: absolute;
            right: 0; 
            top: 50%; 
            transform: translateY(-50%); 
            background: none; 
            border: none; 
            color: var(--text-color); 
            font-size: 1.5rem; 
            cursor: pointer; 
            padding: 0.5rem;
        }

        /* --- Container dos Grupos (MODIFICADO PARA FASE 1) --- */
        #groups-container {
            display: flex;
            flex-direction: row;
            overflow-x: auto;   /* Permite a rolagem horizontal dos blocos */
            overflow-y: hidden;
            padding-bottom: 1.5rem;
            gap: 2rem;
            flex-grow: 1;       /* FAZ A ÁREA DOS GRUPOS CRESCER PARA OCUPAR O ESPAÇO VERTICAL */
        }

        /* --- [NOVO] Estilo para o Layout em Grade Centralizado --- */
        #groups-container.layout-centered {
            flex-direction: row;
            flex-wrap: wrap;
            justify-content: center;
            align-content: flex-start; /* Alinha as linhas ao topo */
            overflow-y: auto;          /* Ativa a rolagem vertical */
            overflow-x: hidden;        /* Desativa a rolagem horizontal */
        }


        /* --- Estilo de cada Grupo (MODIFICADO PARA FASE 1) --- */
        .group {
            background-color: var(--group-background);
            border-radius: 16px; 
            padding: 1.5rem; 
            border: 1px solid var(--border-color); 
            backdrop-filter: blur(10px); 
            -webkit-backdrop-filter: blur(10px); 
            transition: border-color 0.2s ease, opacity 0.2s ease;
            flex-shrink: 0; 
            align-self: flex-start; 
            display: flex;
            flex-direction: column;
            max-height: calc(100vh - 10rem);
        }
        
        .group.drop-target-group {
            border-color: #3b82f6;
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.5);
        }

        .group-header {
            display: flex;
            justify-content: space-between; 
            align-items: center; 
            margin-bottom: 1.5rem;
            cursor: grab; /* Indica que o header é arrastável */
        }
        .group-header:active {
            cursor: grabbing;
        }

        .group-header h2 {
            font-size: 1.1rem;
            font-weight: 600; 
            letter-spacing: 1px; 
        }
        
        .group-header-actions {
            display: flex;
            align-items: center; 
            gap: 8px; 
        }

        .add-favorite-btn, .group-context-btn {
            cursor: pointer;
        }

        .add-favorite-btn {
            background: rgba(255, 255, 255, 0.1);
            border: none; 
            color: var(--text-color); 
            width: 32px; 
            height: 32px; 
            border-radius: 50%; 
            font-size: 1.5rem; 
            transition: background-color 0.2s;
        }

        .add-favorite-btn:hover {
            background: rgba(255, 255, 255, 0.2);
        }

        .group-context-btn {
            background: none;
            border: none; 
            color: var(--text-color); 
            font-size: 1.5rem; 
            padding: 0.5rem; 
            border-radius: 50%; 
            transition: background-color 0.2s;
        }

        .group-context-btn:hover {
            background-color: rgba(255, 255, 255, 0.2);
        }

        .favorites-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(70px, 1fr)); 
            gap: 1.5rem; 
            /* ...propriedades existentes... */
            overflow-y: auto;  /* A propriedade chave: cria a barra de rolagem vertical apenas quando necessário */
            overflow-x: hidden; /* Evita uma barra de rolagem horizontal indesejada */
            flex-grow: 1;      /* Faz a grade se expandir para preencher a altura disponível no .group */
        }

        .favorite-item {
            position: relative;
            display: flex; 
            flex-direction: column; 
            align-items: center; 
            gap: 0.5rem; 
            text-decoration: none; 
            color: var(--text-color); 
            transition: transform 0.2s ease-in-out; 
            cursor: pointer;
        }
        
        .favorite-item:hover {
            transform: scale(1.08);
        }

        .favorite-item .favicon-container {
            width: 60px;
            height: 60px; 
            border-radius: 12px; 
            background-color: rgba(0, 0, 0, 0.2); 
            display: flex; 
            align-items: center; 
            justify-content: center; 
            overflow: hidden;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.2); 
        }

        .favorite-item img {
            width: 100%;
            height: 100%; 
            object-fit: cover; 
        }

        .favorite-item .name {
            font-size: 0.8rem;
            text-align: center; 
            width: 100%; 
            white-space: nowrap; 
            overflow: hidden; 
            text-overflow: ellipsis;
        }
        
        .favorite-actions {
            position: absolute;
            top: -5px; 
            right: -5px; 
            display: flex; 
            gap: 5px; 
            opacity: 0; 
            visibility: hidden; 
            transition: opacity 0.2s, visibility 0.2s; 
            z-index: 10;
            background-color: rgba(0, 0, 0, 0.7); 
            border-radius: 12px; 
            padding: 3px; 
        }

        .favorite-item:hover .favorite-actions {
            opacity: 1;
            visibility: visible; 
        }

        .action-btn {
            background-color: transparent;
            border: none; 
            color: white; 
            width: 24px; 
            height: 24px; 
            border-radius: 50%; 
            font-size: 12px; 
            cursor: pointer; 
            display: flex; 
            align-items: center; 
            justify-content: center;
            padding: 0; 
            transition: background-color 0.2s; 
        }

        .action-btn:hover {
            background-color: rgba(59, 130, 246, 0.5);
        }

        .delete-fav-btn:hover {
            background-color: rgba(239, 68, 68, 0.5);
        }

        /* --- Estilos de Hierarquia (Subgrupos) --- */
        .subgroup-container {
            margin-top: 1.5rem;
            padding-left: 1rem;
            border-left: 2px solid var(--border-color);
        }

        .subgroup {
            background-color: rgba(0, 0, 0, 0.1);
            padding: 1rem;
            border-radius: 8px;
            margin-bottom: 1rem;
        }

        .subgroup:last-child {
            margin-bottom: 0;
        }

        /* --- Estilos do Modal --- */
        .modal {
            display: none;
            position: fixed; 
            z-index: 1000; 
            left: 0; 
            top: 0; 
            width: 100%; 
            height: 100%; 
            background-color: rgba(0, 0, 0, 0.6); 
            backdrop-filter: blur(5px);
            -webkit-backdrop-filter: blur(5px); 
            align-items: center; 
            justify-content: center; 
        }

        .modal.show {
            display: flex;
        }

        .modal-content {
            background-color: var(--group-background);
            padding: 2rem; 
            border-radius: 16px; 
            border: 1px solid var(--border-color); 
            width: 90%; 
            max-width: 400px; 
            position: relative;
        }

        .modal-content .close-btn {
            position: absolute;
            top: 10px; 
            right: 20px; 
            color: var(--text-color); 
            font-size: 2rem; 
            font-weight: bold; 
            cursor: pointer;
        }
        
        .modal-content h3 {
            margin-bottom: 1.5rem;
            text-align: center; 
        }

        .form-group {
            margin-bottom: 1rem;
        }

        .form-group label {
            display: block;
            margin-bottom: 0.5rem; 
        }

        .form-group input {
            width: 100%;
            padding: 0.75rem; 
            background-color: rgba(0, 0, 0, 0.2); 
            border: 1px solid var(--border-color); 
            border-radius: 8px; 
            color: var(--text-color); 
            font-size: 1rem;
        }
        
        .btn-primary {
            width: 100%;
            padding: 0.75rem; 
            border: none; 
            border-radius: 8px; 
            background-color: #3b82f6; 
            color: white; 
            font-size: 1rem; 
            font-weight: bold; 
            cursor: pointer; 
            margin-top: 1rem;
        }

        /* Classe utilitária para esconder elementos */
        .hidden {
            display: none !important;
        }

        /* Menus de Contexto */
        .context-menu-wrapper {
            display: none;
            position: absolute; 
            background-color: var(--group-background); 
            border: 1px solid var(--border-color); 
            border-radius: 8px; 
            box-shadow: 0 8px 16px rgba(0,0,0,0.3); 
            z-index: 1100; 
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px); 
        }

        .context-menu-wrapper.show {
            display: block;
        }

        .context-menu-wrapper ul {
            list-style: none;
            padding: 0.5rem 0; 
            margin: 0; 
        }

        .context-menu-wrapper li {
            padding: 0.75rem 1.5rem;
            cursor: pointer; 
            transition: background-color 0.2s; 
            white-space: nowrap; 
        }
        
        .context-menu-wrapper li:hover {
            background-color: rgba(59, 130, 246, 0.2);
        }

        #group-context-menu {
            width: 180px;
            box-sizing: border-box; 
        }

        #group-context-menu li {
            padding: 0.75rem 1rem;
        }

        /* --- Estilos para Drag and Drop (ATUALIZADO FASE 1) --- */
        .favorite-item.dragging {
            opacity: 0.5;
            cursor: grabbing; 
        }

        .group.dragging-group {
            opacity: 0.5;
            position: fixed; /* Tira o elemento do fluxo normal */
            z-index: 2000;
            pointer-events: none; /* Evita que o elemento arrastado interfira com o drop */
        }
        
        .placeholder {
            border-radius: 16px;
            border: 2px dashed rgba(255, 255, 255, 0.4);
            background-color: rgba(255, 255, 255, 0.05);
            flex-shrink: 0;
        }

        .favorites-grid.drag-over {
            background-color: rgba(59, 130, 246, 0.1);
            border: 2px dashed rgba(59, 130, 246, 0.4); 
            border-radius: 12px; 
        }
        
        /* --- Estilização da Barra de Rolagem Personalizada --- */

        /* Para navegadores baseados em WebKit (Chrome, Edge, Safari) */
        ::-webkit-scrollbar {
            width: 8px;  /* Largura da barra de rolagem vertical */
            height: 8px; /* Altura da barra de rolagem horizontal */
        }

        ::-webkit-scrollbar-track {
            background: rgba(17, 24, 39, 0.3); /* Fundo da trilha, um pouco mais claro que o fundo principal */
            border-radius: 10px;
        }

        ::-webkit-scrollbar-thumb {
            background-color: rgba(255, 255, 255, 0.3); /* Cor do marcador arrastável */
            border-radius: 10px;
            border: 2px solid transparent; /* Cria um preenchimento falso */
            background-clip: content-box;
        }

        ::-webkit-scrollbar-thumb:hover {
            background-color: rgba(255, 255, 255, 0.5); /* Cor ao passar o mouse */
        }

        /* Para Firefox */
        /* Aplicamos aos elementos que podem ter rolagem no nosso sistema */
        #groups-container, .favorites-grid {
            scrollbar-width: thin; /* Deixa a barra mais fina */
            scrollbar-color: rgba(255, 255, 255, 0.3) rgba(17, 24, 39, 0.3); /* Cor do marcador e da trilha */
        }

    </style>
</head>
<body>

    <div class="container">
        <header class="top-bar">
            <input type="search" id="search-bar" class="search-bar" placeholder="🔎 Pesquisar">
            <button class="context-menu-btn" title="Menu">⋮</button>
        </header>

        <div id="context-menu" class="context-menu-wrapper">
            <ul>
                <li data-action="change-wallpaper">Trocar papel de parede</li>
                <li data-action="restore-wallpaper">Restaurar papel de parede</li>
                <li data-action="import">Importar favoritos</li>
                <li data-action="export">Exportar favoritos</li>
                <li data-action="create-group">Criar novo grupo</li>
                <li data-action="customize-layout">Personalizar</li>
            </ul>
        </div>

        <div id="group-context-menu" class="context-menu-wrapper">
            <ul>
                <li data-action="rename-group">Renomear Grupo</li> 
                <li data-action="delete-group" style="color: #fca5a5;">Excluir Grupo</li> 
            </ul>
        </div>

        <main id="groups-container">
            </main>
    </div>

    <div id="add-favorite-modal" class="modal">
        <div class="modal-content">
            <span class="close-btn">×</span>
            <h3 id="modal-title">Adicionar Novo Favorito</h3>
            <form id="add-favorite-form">
                <div class="form-group">
                    <label for="favorite-name">Nome</label>
                    <input type="text" id="favorite-name" required> 
                </div>
                <div class="form-group">
                    <label for="favorite-url">URL</label>
                    <input type="url" id="favorite-url" placeholder="https://exemplo.com" required> 
                </div>
                <button type="submit" class="btn-primary" id="modal-submit-btn">Salvar</button>
            </form>
        </div>
    </div>

    <input type="file" id="wallpaper-input" class="hidden" accept="image/*">
    <input type="file" id="import-input" class="hidden" accept=".html,text/html">

    <div id="customize-modal" class="modal">
        <div class="modal-content">
            <span class="close-btn">×</span>
            <h3>Personalizar Layout</h3>
            <form id="customize-form">
                <div class="form-group">
                    <label for="block-width-slider">Largura dos Blocos (<span id="block-width-value">320</span>px)</label>
                    <input type="range" id="block-width-slider" min="250" max="800" step="10">
                </div>
                <div class="form-group">
                    <label for="center-blocks-checkbox" style="display: flex; align-items: center; cursor: pointer; font-weight: normal;">
                        <input type="checkbox" id="center-blocks-checkbox" style="width: auto; height: auto; margin-right: 10px; cursor: pointer;">
                        Centralizar Blocos (Layout em Grade)
                    </label>
                </div>
                <button type="submit" class="btn-primary">Salvar Alterações</button>
                <button type="button" id="reset-width-btn" class="btn-secondary" style="background-color: #555; margin-top: 10px; width:100%; padding: 0.75rem; border:none; border-radius: 8px; color: white; cursor:pointer;">Redefinir para o Padrão</button>
            </form>
        </div>
    </div>

<script>
    // --- Funções de Exportação (Hierárquica) ---
    function generateExportHTML() {
        let htmlContent = `<!DOCTYPE NETSCAPE-Bookmark-file-1>
    <META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=UTF-8">
    <TITLE>Bookmarks</TITLE>
    <H1>Bookmarks</H1>
    <DL><p>`;

        function buildHtmlForGroups(groups) {
            groups.forEach(group => {
                htmlContent += `\n<DT><H3>${group.name}</H3>`;
                htmlContent += `\n<DL><p>`;
                if (group.favorites) {
                    group.favorites.forEach(fav => {
                        htmlContent += `\n<DT><A HREF="${fav.url}">${fav.name}</A>`;
                    });
                }
                if (group.subgroups && group.subgroups.length > 0) {
                    buildHtmlForGroups(group.subgroups);
                }
                htmlContent += `\n</DL><p>`;
            });
        }
        
        buildHtmlForGroups(appData.groups);
        htmlContent += `\n</DL><p>`;
        return htmlContent;
    }

    function exportFavorites() {
        const htmlContent = generateExportHTML();
        const blob = new Blob([htmlContent], { type: 'text/html' });
        const link = document.createElement('a');
        link.href = URL.createObjectURL(blob);
        link.download = `favoritos_exportados_${new Date().toLocaleDateString()}.html`;
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        URL.revokeObjectURL(link.href);
    }
    
    // --- Camada de Lógica e Persistência ---
    const defaultData = {
        "groups": [
            {
                "id": "1",
                "name": "Favoritos",
                "favorites": []
            }
        ],
        "background": null,
        "settings": {
            "blockWidth": 320,
            "centerBlocks": false // [NOVO] Adiciona a configuração de layout
        }
    };

    let appData = {};

    function loadData() {
        const savedData = localStorage.getItem('launcherFavorites');
        appData = savedData ? JSON.parse(savedData) : defaultData;

        // Garante que a estrutura de dados seja consistente
        if (!appData.settings) {
            appData.settings = defaultData.settings;
        }
    }

    function saveData() {
        localStorage.setItem('launcherFavorites', JSON.stringify(appData));
    }

    // --- Funções de Papel de Parede ---
    function applyWallpaper() {
        const savedWallpaper = appData.background;
        if (savedWallpaper) {
            document.body.style.backgroundImage = `url(${savedWallpaper})`;
        } else {
            document.body.style.backgroundImage = 'linear-gradient(145deg, var(--background-start), var(--background-end))';
        }
    }

    function handleWallpaperSelect(event) {
        const file = event.target.files[0];
        if (!file) return;
        const reader = new FileReader();
        reader.onload = (e) => {
            appData.background = e.target.result;
            saveData();
            applyWallpaper();
        };
        reader.readAsDataURL(file);
    }    

    function openWallpaperSelector() {
        document.getElementById('wallpaper-input').click();
    }

    function restoreDefaultWallpaper() {
        appData.background = null;
        saveData();
        applyWallpaper();
    }
    
    // --- Funções de Importação ---
    function parseBookmarks(htmlString) {
        const parser = new DOMParser();
        const doc = parser.parseFromString(htmlString, 'text/html');
        const mainDl = doc.querySelector('dl');
        if (!mainDl) {
            alert('Arquivo de favoritos inválido ou em formato não reconhecido.');
            return [];
        }
        return buildTree(mainDl);
    }

    function buildTree(dlElement) {
        const items = [];
        const dtElements = dlElement.querySelectorAll(':scope > dt');
        dtElements.forEach(dt => {
            const h3 = dt.querySelector('h3');
            if (h3) {
                const folderName = h3.textContent.trim();
                let nextDl = null;
                let sibling = dt.nextElementSibling;
                while (sibling) {
                    if (sibling.tagName === 'DL') {
                        nextDl = sibling;
                        break;
                    }
                    if (sibling.tagName === 'DT') {
                        break;
                    }
                    sibling = sibling.nextElementSibling;
                }
                const nestedDl = dt.querySelector('dl');
                const children = nestedDl ? buildTree(nestedDl) : (nextDl ? buildTree(nextDl) : []);
                items.push({ type: 'folder', name: folderName, children: children });
            } else {
                const link = dt.querySelector('a');
                if (link) {
                    items.push({ type: 'bookmark', name: link.textContent.trim(), url: link.href });
                }
            }
        });
        return items;
    }

    function convertTreeToAppGroups(tree) {
        const groups = [];
        const topLevelFolders = tree.filter(item => item.type === 'folder');
        const topLevelBookmarks = tree.filter(item => item.type === 'bookmark');
        if (topLevelBookmarks.length > 0) {
            groups.push({
                id: `group-${Date.now()}-root`,
                name: 'Favoritos Raiz',
                favorites: topLevelBookmarks.map(b => ({
                    id: `fav-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,
                    name: b.name,
                    url: b.url
                })),
                subgroups: []
            });
        }
        topLevelFolders.forEach(folder => {
            groups.push(convertFolderToGroup(folder, `group-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`));
        });
        return groups;
    }

    function convertFolderToGroup(folder, id) {
        const group = { id: id, name: folder.name, favorites: [], subgroups: [] };
        folder.children.forEach(child => {
            if (child.type === 'bookmark') {
                group.favorites.push({
                    id: `fav-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,
                    name: child.name,
                    url: child.url
                });
            } else if (child.type === 'folder') {
                group.subgroups.push(convertFolderToGroup(child, `group-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`));
            }
        });
        return group;
    }
    
    function handleImportSelect(event) {
        const file = event.target.files[0];
        if (!file) return;
        const reader = new FileReader();
        reader.onload = (e) => {
            try {
                const parsedTree = parseBookmarks(e.target.result);
                const importedGroups = convertTreeToAppGroups(parsedTree);
                if (importedGroups.length > 0) {
                    appData.groups = [...appData.groups, ...importedGroups];
                    saveData();
                    render();
                    alert(`Importação concluída! ${importedGroups.length} novo(s) grupo(s) adicionado(s).`);
                } else {
                    alert('Nenhuma pasta de favoritos encontrada para importar como grupo.');
                }
            } catch (error) {
                console.error('Erro ao importar favoritos:', error);
                alert('Ocorreu um erro ao tentar importar o arquivo.');
            }
        };
        reader.readAsText(file);
    }
    
    function openImportSelector() {
        document.getElementById('import-input').click();
    }
    
    // --- [NOVO] Função para aplicar o estilo de layout ---
    function applyLayoutSettings() {
        const groupsContainer = document.getElementById('groups-container');
        if (appData.settings && appData.settings.centerBlocks) {
            groupsContainer.classList.add('layout-centered');
        } else {
            groupsContainer.classList.remove('layout-centered');
        }
    }

    // --- Camada de Apresentação (Renderização) ---
    function render() {
        const groupsContainer = document.getElementById('groups-container');
        groupsContainer.innerHTML = '';
        if (appData.groups && appData.groups.length > 0) {
            renderHierarquia(appData.groups, groupsContainer);
        }
    }

    function renderHierarquia(groups, container, isSubgroup = false) {
        groups.forEach(group => {
            const groupElement = document.createElement('section');
            groupElement.className = 'group';
            if (isSubgroup) groupElement.classList.add('subgroup');
            groupElement.dataset.groupId = group.id;
            
            // Aplica a largura personalizada
            if (!appData.settings) appData.settings = { blockWidth: 320, centerBlocks: false };
            const blockWidth = appData.settings.blockWidth || 320;
            groupElement.style.width = `${blockWidth}px`;

            groupElement.innerHTML = `
                <div class="group-header">
                    <h2>${group.name}</h2>
                    <div class="group-header-actions">
                        <button class="add-favorite-btn" title="Adicionar Favorito">+</button>
                        <button class="group-context-btn" title="Opções do Grupo">⋮</button>
                    </div>

                </div>
                <div class="favorites-grid"></div>
                <div class="subgroup-container"></div>
            `;
            
            const favoritesGrid = groupElement.querySelector('.favorites-grid');
            if (group.favorites) {
                group.favorites.forEach(fav => {
                    const faviconUrl = `https://www.google.com/s2/favicons?sz=64&domain_url=${encodeURIComponent(fav.url)}`;
                    const favoriteElement = document.createElement('div');
                    favoriteElement.className = 'favorite-item';
                    favoriteElement.draggable = true; // <-- ESSENCIAL PARA O DRAG-DROP DE FAVORITOS
                    favoriteElement.dataset.favoriteId = fav.id;
                    favoriteElement.dataset.url = fav.url;
                    favoriteElement.innerHTML = `
                        <div class="favorite-actions">
                            <button class="action-btn edit-fav-btn" title="Editar">✏️</button>
                            <button class="action-btn delete-fav-btn" title="Excluir">❌</button>
                        </div>
                        <div class="favicon-container" title="${fav.name}">
                            <img src="${faviconUrl}" alt="" onerror="this.style.display='none'">
                        </div>
                        <span class="name">${fav.name}</span>
                    `;
                    favoritesGrid.appendChild(favoriteElement);
                });
            }
            
            if (group.subgroups && group.subgroups.length > 0) {
                const subgroupContainer = groupElement.querySelector('.subgroup-container');
                renderHierarquia(group.subgroups, subgroupContainer, true);
            }
            
            container.appendChild(groupElement);
        });
    }

    // --- Inicialização e Event Listeners ---
    document.addEventListener('DOMContentLoaded', () => {
        loadData();
        applyLayoutSettings(); // [ALTERADO] Aplica o layout na inicialização
        applyWallpaper();
        render();

        const groupsContainer = document.getElementById('groups-container');
        const searchBar = document.getElementById('search-bar');
        const modal = document.getElementById('add-favorite-modal');
        const closeModalBtn = modal.querySelector('.close-btn');
        const addFavoriteForm = document.getElementById('add-favorite-form');
        const contextMenuBtn = document.querySelector('.context-menu-btn');
        const contextMenu = document.getElementById('context-menu');
        const groupContextMenu = document.getElementById('group-context-menu');
        const wallpaperInput = document.getElementById('wallpaper-input');
        const importInput = document.getElementById('import-input');
        
        let currentGroupId = null;
        let editState = { enabled: false, favoriteId: null };
        let activeGroupId = null;

        // Função auxiliar para encontrar dados de um grupo em qualquer nível
        function findGroupData(groupId, groupsArray) {
            for (let i = 0; i < groupsArray.length; i++) {
                const group = groupsArray[i];
                if (group.id === groupId) {
                    return { group: group, parentArray: groupsArray, index: i };
                }
                if (group.subgroups && group.subgroups.length > 0) {
                    const found = findGroupData(groupId, group.subgroups);
                    if (found) return found;
                }
            }
            return null;
        }
        
        // =================================================================
        // LÓGICA DE DRAG AND DROP PARA GRUPOS (Sistema com Pointer Events)
        // =================================================================
        let draggedGroup = null;
        let placeholder = null;
        let isDraggingGroup = false;
        let dragOffsetX = 0, dragOffsetY = 0;

    groupsContainer.addEventListener('pointerdown', e => {
                // A verificação que desativava o arraste foi removida daqui.
                
                if (e.target.closest('.favorite-item')) return; // Ignora se o clique for em um favorito

                const groupHeader = e.target.closest('.group-header');
                if (!groupHeader || e.button !== 0) return;

                e.preventDefault();
                draggedGroup = groupHeader.closest('.group');
                const rect = draggedGroup.getBoundingClientRect();
                dragOffsetX = e.clientX - rect.left;
                dragOffsetY = e.clientY - rect.top;

                document.addEventListener('pointermove', onGroupPointerMove);
                document.addEventListener('pointerup', onGroupPointerUp);
            });

        function onGroupPointerMove(e) {
            e.preventDefault();
            if (!draggedGroup) return;

            if (!isDraggingGroup) {
                isDraggingGroup = true;
                const rect = draggedGroup.getBoundingClientRect();
                placeholder = document.createElement('div');
                placeholder.className = 'placeholder';
                placeholder.style.width = `${rect.width}px`;
                placeholder.style.height = `${rect.height}px`;
                groupsContainer.insertBefore(placeholder, draggedGroup);
                draggedGroup.classList.add('dragging-group');
                draggedGroup.style.width = `${rect.width}px`;
                document.body.appendChild(draggedGroup);
            }
            
            draggedGroup.style.left = `${e.clientX - dragOffsetX}px`;
            draggedGroup.style.top = `${e.clientY - dragOffsetY}px`;

            document.querySelectorAll('.group.drop-target-group').forEach(g => g.classList.remove('drop-target-group'));
            let dropTarget = e.target.closest('.group:not(.dragging-group)');
            if (dropTarget) {
                 dropTarget.classList.add('drop-target-group');
                 placeholder.style.display = 'none';
            } else {
                 placeholder.style.display = 'block';
                 const children = [...groupsContainer.children].filter(c => c !== placeholder && c !== draggedGroup);
                 let found = false;
                 for(let i=0; i < children.length; i++) {
                     const child = children[i];
                     const box = child.getBoundingClientRect();
                     if(e.clientX < box.left + box.width / 2) {
                         groupsContainer.insertBefore(placeholder, child);
                         found = true;
                         break;
                     }
                 }
                 if (!found) groupsContainer.appendChild(placeholder);
            }
        }
        
        function onGroupPointerUp(e) {
            if (!isDraggingGroup) {
                document.removeEventListener('pointermove', onGroupPointerMove);
                document.removeEventListener('pointerup', onGroupPointerUp);
                return;
            }

            const draggedGroupId = draggedGroup.dataset.groupId;
            const dropTargetElement = document.querySelector('.group.drop-target-group');
            const sourceInfo = findGroupData(draggedGroupId, appData.groups);

            if (dropTargetElement) {
                const targetGroupId = dropTargetElement.dataset.groupId;
                const targetInfo = findGroupData(targetGroupId, appData.groups);
                if (sourceInfo && targetInfo && sourceInfo.group.id !== targetInfo.group.id) {
                    const [movedGroup] = sourceInfo.parentArray.splice(sourceInfo.index, 1);
                    if(!targetInfo.group.subgroups) targetInfo.group.subgroups = [];
                    targetInfo.group.subgroups.push(movedGroup);
                }
            } else if (placeholder) {
                const finalIndex = [...groupsContainer.children].indexOf(placeholder);
                if (sourceInfo) {
                    const [movedGroup] = sourceInfo.parentArray.splice(sourceInfo.index, 1);
                    appData.groups.splice(finalIndex, 0, movedGroup);
                }
            }

            // A ordem da limpeza e renderização foi ajustada para corrigir o bug.
            
            // 1. Salva a nova ordem dos dados
            saveData();
            
            // 2. Remove os elementos visuais temporários do arraste
            if (placeholder) placeholder.remove();

            // [CORREÇÃO] Remove o bloco "fantasma" que foi usado para o arraste visual.
            // A função render() irá recriá-lo no lugar certo a partir dos dados.
            if (draggedGroup) draggedGroup.remove(); 
            
            document.querySelectorAll('.group.drop-target-group').forEach(g => g.classList.remove('drop-target-group'));

            // 3. Limpa as variáveis de estado e os listeners
            draggedGroup = null; 
            placeholder = null; 
            isDraggingGroup = false;
            document.removeEventListener('pointermove', onGroupPointerMove);
            document.removeEventListener('pointerup', onGroupPointerUp);

            // 4. Renderiza a interface com a nova ordem, já sem os elementos fantasmas
            render();
        }
        
        // =================================================================
        // LÓGICA DE DRAG AND DROP PARA FAVORITOS (Sistema com Draggable API) - RESTAURADO
        // =================================================================
        let draggedItem = null;
        let sourceGroupId = null;

        groupsContainer.addEventListener('dragstart', (e) => {
            const favoriteItem = e.target.closest('.favorite-item');
            if (favoriteItem) {
                draggedItem = favoriteItem;
                sourceGroupId = favoriteItem.closest('.group').dataset.groupId;
                setTimeout(() => favoriteItem.classList.add('dragging'), 0);
            }
        });

        groupsContainer.addEventListener('dragover', (e) => {
            e.preventDefault();
            const targetGrid = e.target.closest('.favorites-grid');
            if(targetGrid){
                document.querySelectorAll('.favorites-grid.drag-over').forEach(grid => grid.classList.remove('drag-over'));
                targetGrid.classList.add('drag-over');
            }
        });

        groupsContainer.addEventListener('dragleave', (e) => {
            const targetGrid = e.target.closest('.favorites-grid');
            if (targetGrid) targetGrid.classList.remove('drag-over');
        });

        groupsContainer.addEventListener('drop', (e) => {
            e.preventDefault();
            const targetGroupElement = e.target.closest('.group');
            if (!targetGroupElement || !draggedItem) return;

            const targetGroupId = targetGroupElement.dataset.groupId;
            const favoriteId = draggedItem.dataset.favoriteId;
            
            const sourceInfo = findGroupData(sourceGroupId, appData.groups);
            const targetInfo = findGroupData(targetGroupId, appData.groups);
            
            if (!sourceInfo || !targetInfo) return;

            const favIndex = sourceInfo.group.favorites.findIndex(f => f.id === favoriteId);
            if(favIndex === -1) return;

            const [favoriteToMove] = sourceInfo.group.favorites.splice(favIndex, 1);
            if(!targetInfo.group.favorites) targetInfo.group.favorites = [];
            targetInfo.group.favorites.push(favoriteToMove);
            
            saveData();
            render();
        });

        groupsContainer.addEventListener('dragend', (e) => {
            if (draggedItem) {
                draggedItem.classList.remove('dragging');
                document.querySelectorAll('.favorites-grid.drag-over').forEach(grid => grid.classList.remove('drag-over'));
                draggedItem = null;
                sourceGroupId = null;
            }
        });

        // =================================================================
        // LÓGICA GERAL DE EVENTOS E MENUS
        // =================================================================
        window.addEventListener('click', (e) => {
            if (!contextMenu.contains(e.target) && !contextMenuBtn.contains(e.target)) contextMenu.classList.remove('show');
            if (!groupContextMenu.contains(e.target) && !e.target.classList.contains('group-context-btn')) groupContextMenu.classList.remove('show');
        });

        // Listener do Menu de Contexto Principal (CORRIGIDO)
    contextMenuBtn.addEventListener('click', (e) => {
        e.stopPropagation();
        groupContextMenu.classList.remove('show'); // Garante que o outro menu feche
        
        const rect = e.target.getBoundingClientRect();
        
        // Posiciona o menu 5px abaixo do botão
        contextMenu.style.top = `${rect.bottom + 5}px`; 
        
        // --- LÓGICA DE POSICIONAMENTO CORRIGIDA ---
        // Reseta o 'left' para não haver conflito
        contextMenu.style.left = 'auto'; 
        // Calcula a distância da borda direita do botão até a borda direita da tela
        // e usa a propriedade 'right' do CSS para alinhar o menu.
        contextMenu.style.right = `${window.innerWidth - rect.right}px`; 

        contextMenu.classList.toggle('show');
    });
        contextMenu.addEventListener('click', (e) => {
            const action = e.target.dataset.action;
            if (!action) return;            
            switch (action) {
                case 'change-wallpaper': openWallpaperSelector(); break;
                case 'restore-wallpaper': restoreDefaultWallpaper(); break;
                case 'import': openImportSelector(); break;
                case 'export': exportFavorites(); break;
                case 'create-group':
                    const groupName = prompt('Digite o nome do novo grupo:');
                    if (groupName) {
                        if(!appData.groups) appData.groups = [];
                        appData.groups.push({ id: 'group' + Date.now(), name: groupName, favorites: [], subgroups: [] });
                        saveData();
                        render();
                    }
                    break;
                case 'customize-layout':
                    openCustomizeModal();
                    contextMenu.classList.remove('show');
                    break;
            }
            contextMenu.classList.remove('show');
        });

        groupContextMenu.addEventListener('click', (e) => {
            const action = e.target.dataset.action;
            if (!action || !activeGroupId) return;

            const groupInfo = findGroupData(activeGroupId, appData.groups);
            if (!groupInfo) return;

            if (action === 'rename-group') {
                const newName = prompt('Digite o novo nome para o grupo:', groupInfo.group.name);
                if (newName && newName.trim()) {
                    groupInfo.group.name = newName.trim();
                }
            } else if (action === 'delete-group') {
                if (confirm(`Tem certeza que deseja excluir o grupo "${groupInfo.group.name}" e todos os seus itens?`)) {
                    groupInfo.parentArray.splice(groupInfo.index, 1);
                }
            }

            saveData();
            render();
            groupContextMenu.classList.remove('show');
        });
        
        groupsContainer.addEventListener('click', (e) => {
            const target = e.target;
            const groupElement = target.closest('.group');
            if (!groupElement) return;

            if (target.classList.contains('add-favorite-btn')) {
                currentGroupId = groupElement.dataset.groupId;
                openModal(false);
                return;
            }

            if (target.classList.contains('group-context-btn')) {
                e.stopPropagation();
                activeGroupId = groupElement.dataset.groupId;
                const rect = target.getBoundingClientRect();
                contextMenu.classList.remove('show');
                groupContextMenu.style.top = `${rect.bottom + 5}px`;
                groupContextMenu.style.left = `${rect.right - groupContextMenu.offsetWidth}px`;
                groupContextMenu.classList.add('show');
                return;
            }
            
            const favoriteElement = target.closest('.favorite-item');
            if (!favoriteElement) return;

            const favoriteId = favoriteElement.dataset.favoriteId;
            const groupId = groupElement.dataset.groupId;
            const groupInfo = findGroupData(groupId, appData.groups);

            if (target.classList.contains('edit-fav-btn')) {
                e.preventDefault(); e.stopPropagation();
                const favorite = groupInfo.group.favorites.find(f => f.id === favoriteId);
                if (favorite) {
                    currentGroupId = groupId;
                    editState = { enabled: true, favoriteId: favorite.id };
                    openModal(true, favorite);
                }
                return;
            }

            if (target.classList.contains('delete-fav-btn')) {
                e.preventDefault(); e.stopPropagation();
                const favIndex = groupInfo.group.favorites.findIndex(f => f.id === favoriteId);
                if (favIndex !== -1 && confirm(`Excluir "${groupInfo.group.favorites[favIndex].name}"?`)) {
                    groupInfo.group.favorites.splice(favIndex, 1);
                    saveData();
                    render();
                }
                return;
            }
            
            const url = favoriteElement.dataset.url;
            if(url) window.open(url, '_blank');
        });

        function openModal(isEdit, favorite = null) {
            modal.querySelector('h3').textContent = isEdit ? 'Editar Favorito' : 'Adicionar Novo Favorito';
            document.getElementById('favorite-name').value = isEdit ? favorite.name : '';
            document.getElementById('favorite-url').value = isEdit ? favorite.url : '';
            modal.classList.add('show');
            document.getElementById('favorite-name').focus();
        }

        function closeModal() {
            addFavoriteForm.reset();
            modal.classList.remove('show');
            currentGroupId = null;
            editState = { enabled: false, favoriteId: null };
        }

        closeModalBtn.addEventListener('click', closeModal);
        modal.addEventListener('click', (e) => e.target === modal && closeModal());

        addFavoriteForm.addEventListener('submit', (e) => {
            e.preventDefault();
            const name = document.getElementById('favorite-name').value.trim();
            const url = document.getElementById('favorite-url').value.trim();
            if(!name || !url) return;
            
            const groupInfo = findGroupData(currentGroupId, appData.groups);
            if (!groupInfo) return;

            if (editState.enabled) {
                const favorite = groupInfo.group.favorites.find(f => f.id === editState.favoriteId);
                if (favorite) {
                    favorite.name = name;
                    favorite.url = url;
                }
            } else {
                if(!groupInfo.group.favorites) groupInfo.group.favorites = [];
                groupInfo.group.favorites.push({ id: 'fav' + Date.now(), name, url });
            }
            saveData();
            render();
            closeModal();
        });

        searchBar.addEventListener('input', (e) => {
            const query = e.target.value.toLowerCase().trim();
            document.querySelectorAll('.group').forEach(groupEl => {
                let hasVisibleFavorites = false;
                groupEl.querySelectorAll('.favorite-item').forEach(favEl => {
                    const name = favEl.querySelector('.name').textContent.toLowerCase();
                    const isVisible = name.includes(query);
                    favEl.style.display = isVisible ? '' : 'none';
                    if (isVisible) hasVisibleFavorites = true;
                });
                const groupTitle = groupEl.querySelector('h2').textContent.toLowerCase();
                groupEl.style.display = (groupTitle.includes(query) || hasVisibleFavorites) ? '' : 'none';
            });
        });

        wallpaperInput.addEventListener('change', handleWallpaperSelect);
        importInput.addEventListener('change', handleImportSelect);

        // Lógica para o modal de personalização
        const customizeModal = document.getElementById('customize-modal');
        const closeCustomizeModalBtn = customizeModal.querySelector('.close-btn');
        const customizeForm = document.getElementById('customize-form');
        const blockWidthSlider = document.getElementById('block-width-slider');
        const blockWidthValueSpan = document.getElementById('block-width-value');
        const resetWidthBtn = document.getElementById('reset-width-btn');
        const centerBlocksCheckbox = document.getElementById('center-blocks-checkbox'); // [NOVO] Pega o checkbox
        const DEFAULT_BLOCK_WIDTH = 320;

        // Função para abrir o modal de personalização
        function openCustomizeModal() {
            // [ALTERADO] Carrega as configurações de layout ao abrir o modal
            if (!appData.settings) appData.settings = { blockWidth: DEFAULT_BLOCK_WIDTH, centerBlocks: false };
            const currentWidth = appData.settings.blockWidth || DEFAULT_BLOCK_WIDTH;
            const isCentered = appData.settings.centerBlocks || false;
            
            blockWidthSlider.value = currentWidth;
            blockWidthValueSpan.textContent = currentWidth;
            centerBlocksCheckbox.checked = isCentered;

            customizeModal.classList.add('show');
        }

        // Atualiza o valor em texto enquanto o usuário arrasta o slider
        blockWidthSlider.addEventListener('input', () => {
            blockWidthValueSpan.textContent = blockWidthSlider.value;
        });

        // Salva a nova largura
        customizeForm.addEventListener('submit', (e) => {
            e.preventDefault();
            // [ALTERADO] Salva ambas as configurações
            appData.settings.blockWidth = parseInt(blockWidthSlider.value, 10);
            appData.settings.centerBlocks = centerBlocksCheckbox.checked;
            saveData();
            applyLayoutSettings(); // Aplica o novo layout
            render(); // Renderiza novamente para aplicar a largura
            customizeModal.classList.remove('show');
        });

        // Redefine para o padrão
        resetWidthBtn.addEventListener('click', () => {
            // [ALTERADO] Reseta ambas as configurações
            appData.settings.blockWidth = DEFAULT_BLOCK_WIDTH;
            appData.settings.centerBlocks = false;
            saveData();
            applyLayoutSettings(); // Aplica o layout padrão
            render(); // Renderiza novamente
            customizeModal.classList.remove('show');
        });

        // Fecha o modal
        closeCustomizeModalBtn.addEventListener('click', () => {
            customizeModal.classList.remove('show');
        });
        customizeModal.addEventListener('click', (e) => {
            if (e.target === customizeModal) {
                customizeModal.classList.remove('show');
            }
        });
    });
</script>

</body>
</html>